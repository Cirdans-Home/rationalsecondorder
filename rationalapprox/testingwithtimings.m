%% Numerical test of the different approaches with evaluation of timings
% Test of the computation of sinc(A)v based on the usage of exponential
% sum, i.e., on using the inversion of the Fourier transform.

clear; clc; close all;

%% Finite Differences Matrix
N = 2048;
e = ones(N,1);
A = spdiags([-e,2*e,-e],-1:1,N,N);
v = rand(N,1);

% Reference value
ytrue = msincf(full(A))*v;
nt = norm(ytrue);

% Padé approximation
load("../mathematicacodes/sincpadepoles.mat")
poles.name = "{$[n,n]$}-Padé";
index = 1;
for i=1:2:12
    poles.poles{index} = Expression1(i,1:i+1);
    index = index+1;
end
results = testratapprox(A,v,ytrue,poles);
clear poles

% Gauss with expm
index = 1;
errfull = zeros(15,1);
timefull = zeros(15,2);
for N = 1:10
   [yfull,infofull] = sincfourier(A,v,N);
   errfull(index) = norm(yfull-ytrue)/nt;
   timefull(index,1) = infofull.quadpoints;
   timefull(index,2) = infofull.computetime;
   index = index + 1;
end

% Gauss with rational
index = 1;
errrat = zeros(15,1);
timerat = zeros(15,2);
for N = 1:10
   [yrat,inforat] = sincfourier(A,v,N,'gauss','rational');
   errrat(index) = norm(yrat-ytrue)/nt;
   timerat(index,1) = inforat.quadpoints;
   timerat(index,2) = inforat.computetime;
   index = index + 1;
end

% Rational based on exponential
poles.name = "$\mathcal{E}_n$";
for i=2:9
    poles.poles{i-1} = genlagexppol(i);
end
resultsexp = testratapprox(A,v,ytrue,poles);
clear poles

% Rational based on sin
poles.name = "$\overline{\mathcal{L}}_n$";
for i=2:8
    poles.poles{i-1} = genlagpolsym(i);
end
resultssin = testratapprox(A,v,ytrue,poles);
clear poles

%% Graph (Finite Differences)
hfig1=figure(1);
hold on
loglog(results.times,results.relerrors,...
    'Color',[0.4940, 0.1840, 0.5560],...
    'Marker','*','LineWidth',2,'DisplayName','$[n/n]$-Padé');
loglog(resultsexp.times,resultsexp.relerrors,...
    'Marker','*',...
    'Color',[0.9290, 0.6940, 0.1250],'LineWidth',2,...
    'DisplayName','$\mathcal{E}_n$');
loglog(resultssin.times,resultssin.relerrors, ...
    'Marker','*',...
    'Color',[0.8500, 0.3250, 0.0980],'LineWidth',2, ...
    'DisplayName','$\overline{\mathcal{L}}_n$');
loglog(sum(timefull,2),errfull,...
    'Color',[0.4660, 0.6740, 0.1880],...
    'Marker','square','LineWidth',2,'DisplayName','Exp.Sum and expm');
loglog(sum(timerat,2),errrat, ...
    'Color',[0.6350, 0.0780, 0.1840],...
    'Marker','+',...
    'LineWidth',2,'DisplayName','Exp.Sum and Padé')
xlabel('Time (s)')
ylabel('Relative Error')
legend()
set(gca,'XScale','log','YScale','log')
axis tight
grid on
hold off

try
    fid = fopen("Time-1Dlaplacian.tikz","w+");
    matlab2tikz('filehandle',fid,'figurehandle',hfig1,...
        'height','1.3in','width','0.7\columnwidth',...
        'tikzFileComment','Generated by testrunner.m',...
        'parseStrings',false)
    fclose(fid);
catch
end

%% 2D Laplacian

N = 64;
e = ones(N,1);
T = spdiags([-e,2*e,-e],-1:1,N,N);
I = speye(N,N);
A = kron(T,I) + kron(I,T);
v = rand(N^2,1);

% Reference value
ytrue = msincf(full(A))*v;
nt = norm(ytrue);

% Padé approximation
load("../mathematicacodes/sincpadepoles.mat")
poles.name = "{$[n,n]$}-Padé";
index = 1;
for i=1:2:16
    poles.poles{index} = Expression1(i,1:i+1);
    index = index+1;
end
results = testratapprox(A,v,ytrue,poles);

% Gauss with expm
index = 1;
errfull = zeros(15,1);
timefull = zeros(15,2);
for N = 1:15
   [yfull,infofull] = sincfourier(A,v,N);
   errfull(index) = norm(yfull-ytrue)/nt;
   timefull(index,1) = infofull.quadpoints;
   timefull(index,2) = infofull.computetime;
   index = index + 1;
end

% Gauss with rational
index = 1;
errrat = zeros(15,1);
timerat = zeros(15,2);
for N = 1:15
   [yrat,inforat] = sincfourier(A,v,N,'gauss','rational',20);
   errrat(index) = norm(yrat-ytrue)/nt;
   timerat(index,1) = inforat.quadpoints;
   timerat(index,2) = inforat.computetime;
   index = index + 1;
end

% Rational based on exponential
poles.name = "$\mathcal{E}_n$";
for i=2:9
    poles.poles{i-1} = genlagexppol(i);
end
resultsexp = testratapprox(A,v,ytrue,poles);
clear poles

% Rational based on sin
poles.name = "$\overline{\mathcal{L}}_n$";
for i=2:10
    poles.poles{i-1} = genlagpolsym(i);
end
resultssin = testratapprox(A,v,ytrue,poles);
clear poles

%% Graph (2D Finite Differences)
hfig2=figure(2);
hold on
loglog(results.times,results.relerrors,...
    'Color',[0.4940, 0.1840, 0.5560],...
    'Marker','*','LineWidth',2,'DisplayName','$[n/n]$-Padé');
loglog(resultsexp.times,resultsexp.relerrors,...
    'Marker','*',...
    'Color',[0.9290, 0.6940, 0.1250],'LineWidth',2,...
    'DisplayName','$\mathcal{E}_n$');
loglog(resultssin.times,resultssin.relerrors, ...
    'Marker','*',...
    'Color',[0.8500, 0.3250, 0.0980],'LineWidth',2, ...
    'DisplayName','$\overline{\mathcal{L}}_n$');
loglog(sum(timefull,2),errfull,...
    'Color',[0.4660, 0.6740, 0.1880],...
    'Marker','square','LineWidth',2,'DisplayName','Exp.Sum and expm');
loglog(sum(timerat,2),errrat, ...
    'Color',[0.6350, 0.0780, 0.1840],...
    'Marker','+',...
    'LineWidth',2,'DisplayName','Exp.Sum and Padé')
xlabel('Time (s)')
ylabel('Relative Error')
legend()
set(gca,'XScale','log','YScale','log')
axis tight
grid on
hold off

try
    fid = fopen("Time-2Dlaplacian.tikz","w+");
    matlab2tikz('filehandle',fid,'figurehandle',hfig2,...
        'height','1.3in','width','0.7\columnwidth',...
        'tikzFileComment','Generated by testrunner.m',...
        'parseStrings',false)
    fclose(fid);
catch
end

%% 2D FEM (Linear Elements)

f = @(x,y,t) pi^2*(2*t^2 - (x+y).^2).*sin(pi*t.*(x+y));
utrue = @(x,y,t) sin(pi*t.*(x+y));
uprime = @(x,y,t) pi.*(x + y).*cos(pi*t.*(x + y));

% Geometry
% Circle minus a square domain
gd = [     1     3
    0     4
    0     0
    1     1
    0     1
    0     0
    0     0
    0     0
    0     1
    0     1];
sf = 'C1-SQ1';
ns = [67    83
    49    81
    0    49];
g = decsg(gd,sf,ns);

% WAVE EQ. COEFFICIENTS
numberOfPDE = 1; % Scalar problem
M_COEFF = 1; % 2nd derivative in time
D_COEFF = 0; % 1st derivative in time
C_COEFF = 1; % Diffusion tensor/coefficient
A_COEFF = 0; % Reaction coefficient
F_COEFF = @(location,state) f(location.x,location.y,state.time); % Source term
G_D = @(location,state) utrue(location.x,location.y,state.time);

% Create PDE structure and mesh (for space)
hmax = 0.05;    % Length parameter of the mesh
waveeq = createpde(numberOfPDE);    
waveeq_geom = geometryFromEdges(waveeq, g );
msh = generateMesh(waveeq,'GeometricOrder','linear','hmax',hmax);
[P,E,T] = meshToPet(msh );
figure(10)
subplot(1,2,1)
pdegplot(waveeq,"EdgeLabels","on");
subplot(1,2,2)
pdeplot(P,E,T)
axis tight

specifyCoefficients(waveeq,'m', M_COEFF,'d', D_COEFF,'c',...
    C_COEFF,'a', A_COEFF,'f', F_COEFF );
NumEdges = waveeq_geom.NumEdges;

% Fix Boundary Conditions (Time dependent)
for ie = 1: NumEdges
    applyBoundaryCondition(waveeq,'Dirichlet','edge',ie,'h',1,'r',G_D);
end

state.time = 2;
fem_matrix = assembleFEMatrices(waveeq,"nullspace",state);

A = fem_matrix.Kc;
v = rand(size(fem_matrix.Fc));


% Reference value
ytrue = msincf(full(A))*v;
nt = norm(ytrue);

% Padé approximation
load("../mathematicacodes/sincpadepoles.mat")
poles.name = "{$[n,n]$}-Padé";
index = 1;
for i=1:2:14
    poles.poles{index} = Expression1(i,1:i+1);
    index = index+1;
end
results = testratapprox(A,v,ytrue,poles);

% Gauss with expm
index = 1;
errfull = zeros(15,1);
timefull = zeros(15,2);
for N = 1:15
   [yfull,infofull] = sincfourier(A,v,N);
   errfull(index) = norm(yfull-ytrue)/nt;
   timefull(index,1) = infofull.quadpoints;
   timefull(index,2) = infofull.computetime;
   index = index + 1;
end

% Gauss with rational
index = 1;
errrat = zeros(15,1);
timerat = zeros(15,2);
for N = 1:15
   [yrat,inforat] = sincfourier(A,v,N,'gauss','rational',20);
   errrat(index) = norm(yrat-ytrue)/nt;
   timerat(index,1) = inforat.quadpoints;
   timerat(index,2) = inforat.computetime;
   index = index + 1;
end

% Rational based on exponential
poles.name = "$\mathcal{E}_n$";
for i=2:9
    poles.poles{i-1} = genlagexppol(i);
end
resultsexp = testratapprox(A,v,ytrue,poles);
clear poles

% Rational based on sin
poles.name = "$\overline{\mathcal{L}}_n$";
for i=2:12
    poles.poles{i-1} = genlagpolsym(i);
end
resultssin = testratapprox(A,v,ytrue,poles);
clear poles

%% Graph (Linear FEM)
hfig3=figure(3);
hold on
loglog(results.times,results.relerrors,...
    'Color',[0.4940, 0.1840, 0.5560],...
    'Marker','*','LineWidth',2,'DisplayName','$[n/n]$-Padé');
loglog(resultsexp.times,resultsexp.relerrors,...
    'Marker','*',...
    'Color',[0.9290, 0.6940, 0.1250],'LineWidth',2,...
    'DisplayName','$\mathcal{E}_n$');
loglog(resultssin.times,resultssin.relerrors, ...
    'Marker','*',...
    'Color',[0.8500, 0.3250, 0.0980],'LineWidth',2, ...
    'DisplayName','$\overline{\mathcal{L}}_n$');
loglog(sum(timefull,2),errfull,...
    'Color',[0.4660, 0.6740, 0.1880],...
    'Marker','square','LineWidth',2,'DisplayName','Exp.Sum and expm');
loglog(sum(timerat,2),errrat, ...
    'Color',[0.6350, 0.0780, 0.1840],...
    'Marker','+',...
    'LineWidth',2,'DisplayName','Exp.Sum and Padé')
xlabel('Time (s)')
ylabel('Relative Error')
legend('Location','eastoutside')
set(gca,'XScale','log','YScale','log')
axis tight
grid on
hold off

try
    fid = fopen("Time-2Dfemlinear.tikz","w+");
    matlab2tikz('filehandle',fid,'figurehandle',hfig3,...
        'height','1.3in','width','0.7\columnwidth',...
        'tikzFileComment','Generated by testrunner.m',...
        'parseStrings',false)
    fclose(fid);
catch
end

%% Routine to compute dense reference value
function P = msincf(A)
%%MSINCF dense evaluation of matrix sinc function
P = funm(A,@sin);
P = A\P;
end
