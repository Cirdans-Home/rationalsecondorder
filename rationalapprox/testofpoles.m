%% EXECUTE TESTS FOR POLE SELECTION STRATEGIES
% This code execute tests for different matrices and pole selection
% strategies

clear; clc; close all;

%% 1D Laplacian
% Finite differences 1D Laplacian
hfig = figure("Position",[570 851 402 352]);
N = 2048;
e = ones(N,1);
A = spdiags([-e,2*e,-e],-1:1,N,N);
v = rand(N,1);

% Reference value
ytrue = msincf(full(A))*v;

marker = "o";
poles.name = "$\mathcal{L}_n$";
for i=2:15
    poles.poles{i-1} = genlagpol(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig,poles,results,marker);
clear results poles

marker = "+";
poles.name = "$\overline{\mathcal{L}}_n$";
for i=2:8
    poles.poles{i-1} = genlagpolsym(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig,poles,results,marker);
clear results poles

marker = "*";
poles.name = "$\mathcal{E}_n$";
for i=2:9
    poles.poles{i-1} = genlagexppol(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig,poles,results,marker);
clear results poles

marker = "x";
load("../mathematicacodes/sincpadepoles.mat")
poles.name = "{$[n,n]$}-Padé";
for i=1:size(Expression1,1)
    poles.poles{i} = Expression1(i,1:i+1);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig,poles,results,marker);
clear results poles

marker = "square";
poles.name = "$\mathcal{S}_n$";
for i=2:10
    poles.poles{i-1} = genspougepoles(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig,poles,results,marker);
clear results poles

marker = "<";
ev = eig(A);
poles.name = "$\mathcal{C}_n^{\mathcal{P}}$";
for i=1:5
    poles.poles{i} = genlappoles(i,min(ev),max(ev));
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig,poles,results,marker);
clear results poles

try
    fid = fopen("1Dlaplacian.tikz","w+");
    matlab2tikz('filehandle',fid,'figurehandle',hfig,...
        'height','1.3in','width','0.7\columnwidth',...
        'tikzFileComment','Generated by testrunner.m',...
        'parseStrings',false)
    fclose(fid);
catch
end

%% 2D Laplacian
% Finite differences 2D Laplacian
hfig2 = figure("Position",[570 851 402 352]);
N = 64;
e = ones(N,1);
T = spdiags([-e,2*e,-e],-1:1,N,N);
I = speye(N,N);
A = kron(T,I) + kron(I,T);
v = rand(N^2,1);

% Reference value
ytrue = msincf(full(A))*v;

marker = "o";
poles.name = "$\mathcal{L}_n$";
for i=2:15
    poles.poles{i-1} = genlagpol(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig2,poles,results,marker);
clear results poles

marker = "+";
poles.name = "$\overline{\mathcal{L}}_n$";
for i=2:8
    poles.poles{i-1} = genlagpolsym(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig2,poles,results,marker);
clear results poles

marker = "*";
poles.name = "$\mathcal{E}_n$";
for i=2:9
    poles.poles{i-1} = genlagexppol(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig2,poles,results,marker);
clear results poles

marker = "x";
load("../mathematicacodes/sincpadepoles.mat")
poles.name = "{$[n,n]$}-Padé";
for i=1:size(Expression1,1)
    poles.poles{i} = Expression1(i,1:i+1);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig2,poles,results,marker);
clear results poles

marker = "square";
poles.name = "$\mathcal{S}_n$";
for i=2:10
    poles.poles{i-1} = genspougepoles(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig2,poles,results,marker);
clear results poles

marker = "<";
ev = eig(A);
poles.name = "$\mathcal{C}_n^{\mathcal{P}}$";
for i=1:5
    poles.poles{i} = genlappoles(i,min(ev),max(ev));
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig2,poles,results,marker);
clear results poles

try
    fid = fopen("2Dlaplacian.tikz","w+");
    matlab2tikz('filehandle',fid,'figurehandle',hfig2,...
        'height','1.3in','width','0.7\columnwidth',...
        'tikzFileComment','Generated by testrunner.m',...
        'parseStrings',false)
    fclose(fid);
catch
end

%% 2D FEM (Linear Elements)
hfig3 = figure("Position",[570 851 402 352]);
f = @(x,y,t) pi^2*(2*t^2 - (x+y).^2).*sin(pi*t.*(x+y));
utrue = @(x,y,t) sin(pi*t.*(x+y));
uprime = @(x,y,t) pi.*(x + y).*cos(pi*t.*(x + y));

% Geometry
% Circle minus a square domain
gd = [     1     3
    0     4
    0     0
    1     1
    0     1
    0     0
    0     0
    0     0
    0     1
    0     1];
sf = 'C1-SQ1';
ns = [67    83
    49    81
    0    49];
g = decsg(gd,sf,ns);

% WAVE EQ. COEFFICIENTS
numberOfPDE = 1; % Scalar problem
M_COEFF = 1; % 2nd derivative in time
D_COEFF = 0; % 1st derivative in time
C_COEFF = 1; % Diffusion tensor/coefficient
A_COEFF = 0; % Reaction coefficient
F_COEFF = @(location,state) f(location.x,location.y,state.time); % Source term
G_D = @(location,state) utrue(location.x,location.y,state.time);

% Create PDE structure and mesh (for space)
hmax = 0.05;    % Length parameter of the mesh
waveeq = createpde(numberOfPDE);    
waveeq_geom = geometryFromEdges(waveeq, g );
msh = generateMesh(waveeq,'GeometricOrder','linear','hmax',hmax);
[P,E,T] = meshToPet(msh );
figure(10)
subplot(1,2,1)
pdegplot(waveeq,"EdgeLabels","on");
subplot(1,2,2)
pdeplot(P,E,T)
axis tight

specifyCoefficients(waveeq,'m', M_COEFF,'d', D_COEFF,'c',...
    C_COEFF,'a', A_COEFF,'f', F_COEFF );
NumEdges = waveeq_geom.NumEdges;

% Fix Boundary Conditions (Time dependent)
for ie = 1: NumEdges
    applyBoundaryCondition(waveeq,'Dirichlet','edge',ie,'h',1,'r',G_D);
end

state.time = 2;
fem_matrix = assembleFEMatrices(waveeq,"nullspace",state);

A = fem_matrix.Kc;
v = rand(size(fem_matrix.Fc));


% Reference value
ytrue = msincf(full(A))*v;

marker = "o";
poles.name = "$\mathcal{L}_n$";
for i=2:15
    poles.poles{i-1} = genlagpol(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig3,poles,results,marker);
clear results poles

marker = "+";
poles.name = "$\overline{\mathcal{L}}_n$";
for i=2:8
    poles.poles{i-1} = genlagpolsym(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig3,poles,results,marker);
clear results poles

marker = "*";
poles.name = "$\mathcal{E}_n$";
for i=2:9
    poles.poles{i-1} = genlagexppol(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig3,poles,results,marker);
clear results poles

marker = "x";
load("../mathematicacodes/sincpadepoles.mat")
poles.name = "{$[n,n]$}-Padé";
for i=1:size(Expression1,1)
    poles.poles{i} = Expression1(i,1:i+1);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig3,poles,results,marker);
clear results poles

marker = "square";
poles.name = "$\mathcal{S}_n$";
for i=2:10
    poles.poles{i-1} = genspougepoles(i);
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig3,poles,results,marker);
clear results poles

marker = "<";
ev = eig(A);
poles.name = "$\mathcal{C}_n^{\mathcal{P}}$";
for i=1:5
    poles.poles{i} = genlappoles(i,min(ev),max(ev));
end
results = testratapprox(A,v,ytrue,poles);
plotresults(hfig3,poles,results,marker);
clear results poles

try
    fid = fopen("2Dfemlinear.tikz","w+");
    matlab2tikz('filehandle',fid,'figurehandle',hfig3,...
        'height','1.3in','width','0.7\columnwidth',...
        'tikzFileComment','Generated by testrunner.m',...
        'parseStrings',false)
    fclose(fid);
catch
end

%% Routine to compute dense reference value
function P = msincf(A)
%%MSINCF dense evaluation of matrix sinc function
P = funm(A,@sin);
P = A\P;
end
